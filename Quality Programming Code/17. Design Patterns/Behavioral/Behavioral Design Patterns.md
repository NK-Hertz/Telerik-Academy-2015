##Strategy

**1. Причина:**
*	Дефинира семейство от алгоритми, енкапсулира всеки и ги прави взаимозаменяеми. Strategy позволява алгоритъма да варира независимо от клиента, който го използва.
*	Прихваща абстракцията в интерфейс, скрива детайлите по имплементацията в производен клас.

**2. Проблем:**
Една от доминантните стратегии в обектно ориентирания дизайн е 'open/close' принципа.
Фигурата демонстрира как това се постига - енкапсулират се интерфейсните детаили в базов клас и се скрива
 имплементационните детаили в производни класове. Клиентите след това могат да използват интерфейс и да 
 избегнат проблеми свързани с промяна: няма промяна ако се сменят броя на производни класове или ако 
 имплементацията на производен клас се промени.
 ![]
 Обектно ориентираният дизайн показан тук се фокусира да намали обвързаността между конкретни елементи.
 След като клиента използва само абстракцията, а не конкретната реализация на абстракцията, е минимално вързан
 към конкретен алгоритъм и има свободата лесно да сменя и добавя други такива.

**3. Структура:**
Интерфейс обекта може да представлява или абстрактен базов клас или очакванията на клиента, от _подписа на 
метод*_. В първият случай йерархията на наследяване представлява динамичен полиморфизъм. Във вторият случай интерфейс 
обекта представлява шаблонен код в клиента, а йерархията на наследяването представлява статичен полиморфизъм.

![Структура на Strategy](пътя до файла - линк)

_*Мethod signature е името на метод и типа и вида(стойност, референция или изход) на всеки от формалните му параметри, смятани в ред от ляво надясно). Подписът на метод не включва специфично return типа, нито включва модификатора на параметрите, който може да бъде уточнен за най-десния параметър.(Източник MSDN)
Пример: Foo(), Foo(int), Foo(String), Foo(int, string), Foo(string, int)_