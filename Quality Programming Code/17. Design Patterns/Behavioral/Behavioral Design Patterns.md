##Strategy

**1. Причина:**
*	Дефинира семейство от алгоритми, енкапсулира всеки и ги прави взаимозаменяеми. Strategy позволява алгоритъма да варира независимо от клиента, който го използва.
*	Прихваща абстракцията в интерфейс, скрива детайлите по имплементацията в производен клас.

**2. Проблем:**
Една от доминантните стратегии в обектно ориентирания дизайн е 'open/close' принципа.
Фигурата демонстрира как това се постига - енкапсулират се интерфейсните детаили в базов клас и се скрива
 имплементационните детаили в производни класове. Клиентите след това могат да използват интерфейс и да 
 избегнат проблеми свързани с промяна: няма промяна ако се сменят броя на производни класове или ако 
 имплементацията на производен клас се промени.
 ![](https://github.com/NK-Hertz/Telerik-Academy-2015/blob/master/Quality%20Programming%20Code/17.%20Design%20Patterns/Behavioral/images/Strategy%20Problem.png)
 Обектно ориентираният дизайн показан тук се фокусира да намали обвързаността между конкретни елементи.
 След като клиента използва само абстракцията, а не конкретната реализация на абстракцията, е минимално вързан
 към конкретен алгоритъм и има свободата лесно да сменя и добавя други такива.

**3. Структура:**
Интерфейс обекта може да представлява или абстрактен базов клас или очакванията на клиента, от _подписа на 
метод*_. В първият случай йерархията на наследяване представлява динамичен полиморфизъм. Във вторият случай интерфейс 
обекта представлява шаблонен код в клиента, а йерархията на наследяването представлява статичен полиморфизъм.

![Структура на Strategy](https://github.com/NK-Hertz/Telerik-Academy-2015/blob/master/Quality%20Programming%20Code/17.%20Design%20Patterns/Behavioral/images/Strategy%20Structure.png)

_* Мethod signature е името на метод и типа и вида(стойност, референция или изход) на всеки от формалните му параметри, смятани в ред от ляво надясно). Подписът на метод не включва специфично return типа, нито включва модификатора на параметрите, който може да бъде уточнен за най-десния параметър.(Източник MSDN)
Пример: Foo(), Foo(int), Foo(String), Foo(int, string), Foo(string, int)_

##State

**1. Причина:**
*	Позволява на обект да променя поведението си, когато вътрешното му състояние се промени. Обектът ще иглежда, че променя класа си
*	Обектно-ориентирана машина на състоянията(state machine)
*	Обвивка + полиморфен обект, който да бъде в обвивката + сътрудничество

**2. Проблем:**
Поведението на даден обект, е функция на неговото състояние, което трябва да се промени run-time в зависимост от състоянито си.

**3. Дискусия:**
State модела е решение на проблема как да накара поведението да зависи на състоянието.
*	Дефинира 'контекстен' клас да предостави единичен интерфейс на външния свят
*	Дефинира абстрактен базов State клас
*	Представлява различни 'състояния' на машината на състояния(state machine) като производен класове на базовия State клас
*	Дефинира поведение, зависещо от състоянието в подходящия State производен клас
*	Поддържа указател до настоящото 'състояние' в 'контестния' клас
*	Да променя състоянието на state машината, променя текущия 'state' указател 

State модела не уточнява къде промяната на състоянието ще е дефинирано. Изборите са два: 'контекстния' обект или всеки индивидуален State производен клас. Преимуществото на втория начин е леснотата на добавяне на нов State производен клас. Недостатъка му е, че всеки такъв клас знае за неговите братя(другите такива класове), което въвежда зависимост между подкласовете.

**4. Структура:**
Интерфейсът на state машината(state machine) е енкапсулиран в обвиващия клас. Интерфейсът на йерархията на обвития обект имитира интерфейса на обвивката с изключение на един допълнителен параметър. Допълнителния параметър позволява производни класове на обвития обект да се обръщат към обвиващия клас. Сложност, която в други случай би повлякла обвиващия клас е разпределена и енкапсулирана в полиморфна йерархия, до която обвиващия обект делегира.
![](https://github.com/NK-Hertz/Telerik-Academy-2015/blob/master/Quality%20Programming%20Code/17.%20Design%20Patterns/Behavioral/images/State%20Structure.png)

##Interpreter

**1. Причина:**
*	При даден език дефинира репрезентация за граматиката си заедно със интерпретатор, който използва репрезентацията за да преведе изречения от езика
*	Мапва домейн към език, езикът към граматика, а граматиката за йерархичен обектно-ориентиран дизайн

**2. Проблем:**
Клас със проблем се случва отново и отново в добре дефиниран и добре разбран домейн. Ако домейнът бе характеризиран с 'език', тогава проблемите лесно биха били разрешени с интерпретиращ 'двигател'.

**3. Дискисия:**
Interpreter модела дискутира: дефиниране на домейн език като проста езикова граматика, представляваща домейн правила като езикови изречения и превеждането на тези изречения за да се намери решение на проблема. Модела използва клас да представлява всяко граматическо правило. И тъй като граматиката е обикновено йерархична по структура, наследствена йерархия на класовете правила се очаква.

Абстрактен базов клас специфицира метода Interpret(). Всеки конкретен подклас имплементира Interpret() като приема(като параметър) текущото състояние от езиковия поток и добавя неговия принос към процеса за решаване на даден проблем.

**4. Структура:**
Interpreter предлага моделиране на домейна със рекурсивна граматика. Всяко правило в граматиката е или 'composite'(правило, което реферира други правила), 
или терминал(листо в дървовидна структура). Interpreter разчита на рекурсивно обхождане от Composite модел за да преведе 'изреченията', които са му подадени да обработи.
![](https://github.com/NK-Hertz/Telerik-Academy-2015/blob/master/Quality%20Programming%20Code/17.%20Design%20Patterns/Behavioral/images/Interpreter%20Structure.png)

##Memento

**1. Причина:**
*	Без да нарушава енкапсулацията, хваща и изкарва вътрешното състояние на обект така че то да може да бъде
възстановено на по-късен етап
*	Магическа бисквита, която енкапсулира 'checkpoint' способност
*	Промотира 'undo' или отмяна до предишно състояние на обект

**2. Проблем:**
Нужда от възстановяване на обект до предишно състояние.

**3. Структура:**
Клиента прави заявка до Memento от обекта източник, когато има нужда да направи 'checkpoint' на състоянието на 
обекта. Обекта източник инициализира Memento с характирация на състоянието си. Клиента е грижещия се за Memento, но 
единствено обекта източник може да пази и възвръща информация от Memento. Ако клиента има нужда да възстановява 
няколко пъти подред състоянието на обекта източник, подава Memento-то до обекта източник за възстановяване. 
Неограничена 'undo' и 'redo' способност може лесно имплементирана със стек от Command обекти и стек от Memento обекти.
Memento модела дефинира три различни роли:
*1. Основен* - обект, който знае как да се запазва 
*2. Грижещ се* - обект, който знае защо и кога 'Основния' трябва да запази и възстанови себе си
*3. Мементо* - заключена кутия, която се пише и чете от 'Основния' и управлявана от 'Грижещия се'
![](https://github.com/NK-Hertz/Telerik-Academy-2015/blob/master/Quality%20Programming%20Code/17.%20Design%20Patterns/Behavioral/images/Memento%20Structure.png)













